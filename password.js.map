{
  "version": 3,
  "file": "password.js",
  "sourceRoot": "",
  "sources": [
    "coffeescripts/password.coffee"
  ],
  "names": [],
  "mappings": "AAAA;AAAA;;;;;;;;MAAA,MAAA,EAAA,MAAA,EAAA;;EAAA,MAAA,GAAS,OAAA,CAAQ,QAAR;;EACT,MAAA,GAAS,OAAA,CAAQ,UAAR;;EAST,cAAA,GAAiB,CAAC,aAAD,EAAgB,OAAO,IAAvB,CAAA,GAAA;WACf,IAAI,OAAJ,CAAY,KAAA,CAAC,OAAD,EAAU,MAAV,CAAA,GAAA;MACV,IAAG,IAAA,KAAQ,IAAX;QACE,IAAA,GAAO,CAAA,MAAM,MAAM,CAAC,YAAP,CAAoB,EAApB,CAAN,EADT;;aAGA,MAAM,CAAC,MAAP,CAAc,aAAd,EAA6B,IAA7B,EAAmC,EAAnC,EAAuC,CAAC,GAAD,EAAM,UAAN,CAAA,GAAA;QACrC,IAAG,GAAA,KAAS,IAAT,IAAkB,GAAA,KAAS,MAA9B;AACE,iBAAO,MAAA,CAAO,GAAP,EADT;;eAGA,OAAA,CAAQ,MAAM,CAAC,MAAP,CAAc,CAAC,IAAD,EAAO,UAAP,CAAd,CAAR;MAJqC,CAAvC;IAJU,CAAZ;EADe;;EAWjB,MAAM,CAAC,OAAP,GACE;IAAA,IAAA,EAAM,CAAC,aAAD,CAAA,GAAA;aACJ,OAAO,CAAC,OAAR,CAAgB,cAAA,CAAe,aAAf,CAAhB;IADI,CAAN;IAGA,KAAA,EAAO,CAAC,aAAD,EAAgB,eAAhB,CAAA,GAAA;aACL,IAAI,OAAJ,CAAY,KAAA,CAAC,OAAD,EAAU,MAAV,CAAA,GAAA;AACV,YAAA,aAAA,EAAA,IAAA,EAAA;QAAA,IAAG,MAAM,CAAC,QAAP,CAAgB,eAAhB,CAAH;UACE,aAAA,GAAgB,gBADlB;SAAA,MAAA;UAGE,aAAA,GAAgB,MAAM,CAAC,IAAP,CAAY,eAAZ,EAA6B,KAA7B,EAHlB;;QAKA,IAAA,GAAO,aAAa,CAAC,KAAd,CAAoB,CAApB,EAAuB,EAAvB;QACP,IAAA,GAAO,CAAA,MAAM,cAAA,CAAe,aAAf,EAA8B,IAA9B,CAAN;eAEP,OAAA,CAAQ,MAAM,CAAC,OAAP,CAAe,IAAf,EAAqB,aAArB,CAAA,KAAuC,CAA/C;MATU,CAAZ;IADK;EAHP;AAtBF",
  "sourcesContent": [
    "crypto = require \"crypto\"\ncommon = require \"./common\"\n\n###*\n * Hash the password using the Scrypt algorithm.\n *\n * @param {string} plainPassword - The password to hash.\n * @param {string} salt - Additional entropy to use when hashing the password.\n * @returns {Buffer}\n###\nscryptPassword = (plainPassword, salt = null) =>\n  new Promise (resolve, reject) =>\n    if salt is null\n      salt = await common.randomString(32)\n\n    crypto.scrypt plainPassword, salt, 64, (err, derivedKey) =>\n      if err isnt null and err isnt undefined\n        return reject err\n\n      resolve Buffer.concat [salt, derivedKey]\n\nmodule.exports =\n  hash: (plainPassword) =>\n    Promise.resolve scryptPassword(plainPassword)\n\n  match: (plainPassword, derivedPassword) =>\n    new Promise (resolve, reject) =>\n      if Buffer.isBuffer derivedPassword\n        derivedBuffer = derivedPassword\n      else # We assume the string is hex encoded\n        derivedBuffer = Buffer.from derivedPassword, \"hex\"\n\n      salt = derivedBuffer.slice 0, 32\n      hash = await scryptPassword(plainPassword, salt)\n\n      resolve Buffer.compare(hash, derivedBuffer) is 0\n"
  ]
}