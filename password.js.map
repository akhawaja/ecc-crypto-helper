{
  "version": 3,
  "file": "password.js",
  "sourceRoot": "",
  "sources": [
    "coffeescripts/password.coffee"
  ],
  "names": [],
  "mappings": "AAAA;AAAA;;;;;;;;MAAA,UAAA,EAAA,SAAA,EAAA,MAAA,EAAA,MAAA,EAAA,IAAA,EAAA;;EAAA,MAAA,GAAS,OAAA,CAAQ,QAAR;;EACT,MAAA,GAAS,OAAA,CAAQ,UAAR;;EACT,IAAA,GAAO,OAAA,CAAQ,QAAR;;EAEP,SAAA,GAAY;;EACZ,UAAA,GAAa;;EASb,cAAA,GAAiB,CAAC,aAAD,EAAgB,OAAO,IAAvB,CAAA,GAAA;WACf,IAAI,OAAJ,CAAY,KAAA,CAAC,OAAD,EAAU,MAAV,CAAA,GAAA;MACV,IAAG,IAAA,KAAQ,IAAX;QACE,IAAA,GAAO,CAAA,MAAM,MAAM,CAAC,MAAP,CAAc,SAAd,CAAN,EADT;;aAGA,MAAM,CAAC,MAAP,CAAc,aAAd,EAA6B,IAA7B,EAAmC,UAAnC,EAA+C,KAAA,CAAC,GAAD,EAAM,UAAN,CAAA,GAAA;AAC7C,YAAA;QAAA,IAAG,WAAH;AACE,iBAAO,MAAA,CAAO,GAAP,EADT;;QAGA,WAAA,GAAc,CAAA,MAAM,IAAI,CAAC,MAAL,CAAY,UAAZ,EAAwB,UAAxB,EAAoC,IAApC,CAAN;eACd,OAAA,CAAQ,MAAM,CAAC,MAAP,CAAc,CAAC,IAAD,EAAO,WAAP,CAAd,CAAR;MAL6C,CAA/C;IAJU,CAAZ;EADe;;EAYjB,MAAM,CAAC,OAAP,GAOE,CAAA;;;;;;;IAAA,IAAA,EAAM,CAAC,aAAD,CAAA,GAAA;aACJ,OAAO,CAAC,OAAR,CAAgB,cAAA,CAAe,aAAf,CAAhB;IADI,CAAN;;;;;;;;IAUA,KAAA,EAAO,CAAC,aAAD,EAAgB,eAAhB,CAAA,GAAA;aACL,IAAI,OAAJ,CAAY,KAAA,CAAC,OAAD,EAAU,MAAV,CAAA,GAAA;AACV,YAAA,aAAA,EAAA,IAAA,EAAA;QAAA,IAAG,MAAM,CAAC,QAAP,CAAgB,eAAhB,CAAH;UACE,aAAA,GAAgB,gBADlB;SAAA,MAAA;UAGE,aAAA,GAAgB,MAAM,CAAC,IAAP,CAAY,eAAZ,EAA6B,KAA7B,EAHlB;;QAKA,IAAA,GAAO,aAAa,CAAC,KAAd,CAAoB,CAApB,EAAuB,SAAvB;QACP,IAAA,GAAO,CAAA,MAAM,cAAA,CAAe,aAAf,EAA8B,IAA9B,CAAN;eAEP,OAAA,CAAQ,IAAI,CAAC,OAAL,CAAa,aAAb,CAAA,KAA+B,CAAvC;MATU,CAAZ;IADK;EAVP;AAjCF",
  "sourcesContent": [
    "crypto = require \"crypto\"\ncommon = require \"./common\"\nhkdf = require \"./hkdf\"\n\nSALT_SIZE = 64\nKEY_LENGTH = 64\n\n###*\n * Hash the password using the Scrypt algorithm.\n *\n * @param {string} plainPassword - The password to hash.\n * @param {string} salt - Additional entropy to use when hashing the password.\n * @returns {Buffer}\n###\nscryptPassword = (plainPassword, salt = null) =>\n  new Promise (resolve, reject) =>\n    if salt is null\n      salt = await common.random SALT_SIZE\n\n    crypto.scrypt plainPassword, salt, KEY_LENGTH, (err, derivedKey) =>\n      if err?\n        return reject err\n\n      expandedKey = await hkdf.derive(derivedKey, KEY_LENGTH, salt)\n      resolve Buffer.concat [salt, expandedKey]\n\nmodule.exports =\n  ###*\n   * Hash the password using a combination of Scrypt and HKDF.\n   *\n   * @param {string} plainPassword - The password to hash.\n   * @returns {Buffer} The hashed password.\n  ###\n  hash: (plainPassword) =>\n    Promise.resolve scryptPassword plainPassword\n\n  ###*\n   * Verify that the plain password and derivedPassword match.\n   *\n   * @param {string} plainPassword - The plain password.\n   * @param {string|Buffer} derivedPassword - The previously hashed password.\n   * @returns {boolean} true if the password is correct; false otherwise.\n  ###\n  match: (plainPassword, derivedPassword) =>\n    new Promise (resolve, reject) =>\n      if Buffer.isBuffer derivedPassword\n        derivedBuffer = derivedPassword\n      else # We assume the string is hex encoded\n        derivedBuffer = Buffer.from derivedPassword, \"hex\"\n\n      salt = derivedBuffer.slice 0, SALT_SIZE\n      hash = await scryptPassword plainPassword, salt\n\n      resolve hash.compare(derivedBuffer) is 0\n"
  ]
}