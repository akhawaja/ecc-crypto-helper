{
  "version": 3,
  "file": "ksuid.js",
  "sourceRoot": "",
  "sources": [
    "coffeescripts/ksuid.coffee"
  ],
  "names": [],
  "mappings": "AAAA;AAAA,MAAA,KAAA,EAAA,yBAAA,EAAA,UAAA,EAAA,kBAAA,EAAA,oBAAA,EAAA,MAAA,EAAA,MAAA,EAAA,IAAA,EAAA;;EAAA,KAAA,GAAQ;;EACR,yBAAA,GAA2B;;EAC3B,oBAAA,GAAuB;;EACvB,kBAAA,GAAqB;;EACrB,UAAA,GAAa,oBAAA,GAAuB;;EAEpC,KAAA,GAAQ,OAAA,CAAQ,OAAR;;EACR,MAAA,GAAS,OAAA,CAAQ,QAAR;;EACT,MAAA,GAAS,OAAA,CAAQ,UAAR;;EACT,IAAA,GAAO,OAAA,CAAQ,QAAR;;EAEP,MAAM,CAAC,OAAP,GAOE,CAAA;;;;;;;IAAA,MAAA,EAAQ,CAAC,gBAAgB,IAAjB,CAAA,GAAA;aACN,IAAI,OAAJ,CAAY,KAAA,CAAC,OAAD,CAAA,GAAA;AACV,YAAA,UAAA,EAAA,GAAA,EAAA,OAAA,EAAA;QAAA,IAAG,aAAA,KAAiB,IAApB;UACE,GAAA,GAAM,CAAA,MAAM,MAAM,CAAC,YAAP,CAAA,CAAN,EADR;SAAA,MAAA;UAGE,GAAA,GAAM,cAHR;;QAKA,GAAA,GAAM,CAAA,MAAM,MAAM,CAAC,MAAP,CAAc,EAAd,CAAN;QACN,OAAA,GAAU,CAAA,MAAM,IAAI,CAAC,MAAL,CAAY,GAAZ,EAAiB,kBAAjB,CAAN;QACV,UAAA,GAAa,KAAK,CAAC,SAAN,CAAgB,GAAA,GAAM,IAAtB,EAA4B,OAA5B;eACb,OAAA,CAAQ,UAAU,CAAC,MAAnB;MATU,CAAZ;IADM,CAAR;;;;;;;IAkBA,KAAA,EAAO,CAAC,UAAD,CAAA,GAAA;aACL,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,CAAA,GAAA;AACV,YAAA;QAAA,IAAG,UAAU,CAAC,MAAX,KAAuB,yBAA1B;UACE,MAAA,CAAO,IAAI,KAAJ,CAAU,2CAAV,CAAP,EADF;;QAGA,gBAAA,GAAmB,KAAK,CAAC,KAAN,CAAY,UAAZ;eAEnB,OAAA,CAAQ;UACN,KAAA,EAAO,UADD;UAEN,IAAA,EAAM,gBAAgB,CAAC,IAFjB;UAGN,SAAA,EAAW,gBAAgB,CAAC,SAHtB;UAIN,OAAA,EAAS,gBAAgB,CAAC;QAJpB,CAAR;MANU,CAAZ;IADK;EAlBP;AAlBF",
  "sourcesContent": [
    "EPOCH = 14e11\nMAX_ENCODED_STRING_LENGTH= 27\nTIMESTAMP_MAX_LENGTH = 4\nPAYLOAD_MAX_LENGTH = 16\nMAX_LENGTH = TIMESTAMP_MAX_LENGTH + PAYLOAD_MAX_LENGTH\n\nksuid = require \"ksuid\"\ncrypto = require \"crypto\"\ncommon = require \"./common\"\nhkdf = require \"./hkdf\"\n\nmodule.exports =\n  ###*\n   * Create a new KSUID.\n   *\n   * @param {number} unixTimestamp - The UNIX timestamp to use.\n   * @returns {string} The KSUID value.\n  ###\n  create: (unixTimestamp = null) =>\n    new Promise (resolve) =>\n      if unixTimestamp is null\n        utc = await common.utcTimestamp()\n      else\n        utc = unixTimestamp\n\n      ikm = await common.random(32)\n      payload = await hkdf.derive ikm, PAYLOAD_MAX_LENGTH\n      identifier = ksuid.fromParts(utc * 1000, payload)\n      resolve identifier.string\n\n  ###*\n   * Parse a KSUID value and return its component parts.\n   *\n   * @param {string} ksuidValue - The KSUID value to parse.\n   * @returns {Object} The component parts of the KSUID.\n  ###\n  parse: (ksuidValue) =>\n    new Promise (resolve, reject) =>\n      if ksuidValue.length isnt MAX_ENCODED_STRING_LENGTH\n        reject new Error \"ksuidValue does not appear to be a KSUID.\"\n\n      parsedIdentifier = ksuid.parse ksuidValue\n\n      resolve {\n        ksuid: ksuidValue\n        time: parsedIdentifier.date\n        timestamp: parsedIdentifier.timestamp\n        payload: parsedIdentifier.payload\n      }\n"
  ]
}