{
  "version": 3,
  "file": "aesgcm256.js",
  "sourceRoot": "",
  "sources": [
    "coffeescripts/aesgcm256.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "crypto = require \"crypto\"\ncommon = require \"./common\"\nhkdf = require \"./hkdf\"\n\nITERATIONS = 10000\nKEY_LENGTH = 32 # AES-GCM-256 requires a 32-bytes key length\nDIGEST = \"sha512\"\nCIPHER = \"aes-256-gcm\"\nSALT_SIZE = 64\nAUTH_TAG_SIZE = 16\nIV_SIZE = 12 # A 12-bytes (96-bit initialization vector) is recommended for AES-GCM-256\n\nmodule.exports =\n  ###*\n   * Encrypt a string using a secret.\n   *\n   * @param {string} text - The text to encrypt.\n   * @param {string|Buffer} secret - The secret to use for decryption.\n   * @returns {Buffer} The cipher text.\n  ###\n  encrypt: (text, secret) =>\n    new Promise (resolve, reject) =>\n      if typeof text isnt \"string\"\n        reject new Error \"text to encrypt must be a string.\"\n\n      masterKey = null\n\n      # We will presume that the secret is cryptographically strong\n      if Buffer.isBuffer secret\n        masterKey = secret\n      else if typeof secret is \"string\"\n        masterKey = Buffer.from secret\n      else\n        return reject \"secret should be either a String or Buffer. Found '#{typeof secret}'.\"\n\n      salt = await common.random SALT_SIZE\n      iv = await common.random IV_SIZE\n\n      crypto.pbkdf2 masterKey, salt, ITERATIONS, KEY_LENGTH, DIGEST, (err, derivedKey) =>\n        if err?\n          return reject err\n\n        expandedKey = await hkdf.derive derivedKey, KEY_LENGTH, salt\n        cipher = crypto.createCipheriv CIPHER, expandedKey, iv\n        cipherText = Buffer.concat [cipher.update(text, \"utf8\"), cipher.final()]\n        authTag = cipher.getAuthTag()\n        resolve Buffer.concat [salt, iv, authTag, cipherText]\n\n  ###*\n   * Decrypt a previously encrypted text.\n   *\n   * @param {string|Buffer} cipherText - The encrypted text.\n   * @param {string|Buffer} secret - The secret to use for decryption.\n   * @returns {string} The decrypted text.\n  ###\n  decrypt: (cipherText, secret) =>\n    new Promise (resolve, reject) =>\n      masterKey = null\n      cipherTextBuffer = null\n\n      if typeof cipherText is \"string\"\n        cipherTextBuffer = Buffer.from cipherText\n      if Buffer.isBuffer cipherText\n        cipherTextBuffer = cipherText\n      else\n        return reject new Error(\"cipherText should be a Buffer or string. Found '#{typeof cipherTextBuffer}'.\")\n\n      if Buffer.isBuffer secret\n        masterKey = secret\n      else if typeof secret is \"string\"\n        masterKey = Buffer.from secret\n      else\n        return reject \"secret should be either a String or Buffer. Found '#{typeof secret}'.\"\n\n      salt = cipherTextBuffer.slice 0, SALT_SIZE\n      iv = cipherTextBuffer.slice SALT_SIZE, SALT_SIZE + IV_SIZE\n      authTag = cipherTextBuffer.slice SALT_SIZE + IV_SIZE, SALT_SIZE + IV_SIZE + AUTH_TAG_SIZE\n      cipherText = cipherTextBuffer.slice SALT_SIZE + IV_SIZE + AUTH_TAG_SIZE\n      crypto.pbkdf2 masterKey, salt, ITERATIONS, KEY_LENGTH, DIGEST, (err, derivedKey) =>\n        expandedKey = await hkdf.derive derivedKey, KEY_LENGTH, salt\n        cipher = crypto.createDecipheriv CIPHER, expandedKey, iv\n        cipher.setAuthTag authTag\n        text = cipher.update(cipherText, \"binary\", \"utf8\") + cipher.final(\"utf8\")\n        resolve text\n"
  ]
}