{
  "version": 3,
  "file": "aesgcm256.js",
  "sourceRoot": "",
  "sources": [
    "coffeescripts/aesgcm256.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "crypto = require \"crypto\"\ncommon = require \"./common\"\n\nITERATIONS = 10000\nKEY_LENGTH = 32 # AES-GCM-256 requires a 32-bytes key length\nDIGEST = \"sha512\"\nCIPHER = \"aes-256-gcm\"\n\nmodule.exports =\n  ###*\n   * Encrypt a string using a secret.\n   *\n   * @param {string} text - The text to encrypt.\n   * @param {string|Buffer} secret - The secret to use for decryption.\n   * @returns {Buffer} The cipher text.\n  ###\n  encrypt: (text, secret) =>\n    new Promise (resolve, reject) =>\n      if typeof text isnt \"string\"\n        reject new Error \"text to encrypt must be a string.\"\n\n      masterKey = null\n\n      # We will presume that the secret is cryptographically strong\n      if Buffer.isBuffer secret\n        masterKey = secret\n      else if typeof secret is \"string\"\n        masterKey = Buffer.from secret\n      else\n        return reject \"secret should be either a String or Buffer. Found '#{typeof secret}'.\"\n\n      salt = await common.random 64\n      iv = await common.random 12 # A 12-bytes (96-bit initialization vector) is recommended for AES-GCM-256\n\n      crypto.pbkdf2 masterKey, salt, ITERATIONS, KEY_LENGTH, DIGEST, (err, derivedKey) =>\n        if err?\n          return reject err\n\n        cipher = crypto.createCipheriv CIPHER, derivedKey, iv\n        cipherText = Buffer.concat [cipher.update(text, \"utf8\"), cipher.final()]\n        authTag = cipher.getAuthTag()\n        resolve Buffer.concat [salt, iv, authTag, cipherText]\n\n  ###*\n   * Decrypt a previously encrypted text.\n   *\n   * @param {string|Buffer} cipherText - The encrypted text.\n   * @param {string|Buffer} secret - The secret to use for decryption.\n   * @returns {string} The decrypted text.\n  ###\n  decrypt: (cipherText, secret) =>\n    new Promise (resolve, reject) =>\n      masterKey = null\n      cipherTextBuffer = null\n\n      if typeof cipherText is \"string\"\n        cipherTextBuffer = Buffer.from cipherText\n      if Buffer.isBuffer cipherText\n        cipherTextBuffer = cipherText\n      else\n        return reject new Error(\"cipherText should be a Buffer or string. Found '#{typeof cipherTextBuffer}'.\")\n\n      if Buffer.isBuffer secret\n        masterKey = secret\n      else if typeof secret is \"string\"\n        masterKey = Buffer.from secret\n      else\n        return reject \"secret should be either a String or Buffer. Found '#{typeof secret}'.\"\n\n      salt = cipherTextBuffer.slice 0, 64\n      iv = cipherTextBuffer.slice 64, 76\n      authTag = cipherTextBuffer.slice 76, 92\n      cipherText = cipherTextBuffer.slice 92\n      crypto.pbkdf2 masterKey, salt, ITERATIONS, KEY_LENGTH, DIGEST, (err, derivedKey) =>\n        cipher = crypto.createDecipheriv CIPHER, derivedKey, iv\n        cipher.setAuthTag authTag\n        text = cipher.update(cipherText, \"binary\", \"utf8\") + cipher.final(\"utf8\")\n        resolve text\n"
  ]
}